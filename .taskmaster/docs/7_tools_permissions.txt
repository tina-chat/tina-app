# PRD-07: Tools & Security Permissions

## User Value Proposition
Provide safe, controlled execution of AI tools with granular permission management, giving users confidence that tools only perform approved actions while maintaining transparency of all operations.

## User Stories (Vertical Slices)
- As a user, I want to approve tool usage so that I control what actions the AI takes
- As a user, I want different permission levels so that I can trust frequently-used tools
- As a user, I want to see what tools are doing so that I understand the AI's actions
- As a user, I want to revoke permissions so that I can change my mind about tool access
- As a user, I want execution traces so that I can audit what happened

## Success Criteria
- 5-level permission system (Deny, Allow once, Session, Chat, Workflow)
- Permission prompts with clear descriptions
- Execution trace panel showing all tool calls
- Tool I/O visibility (collapsible)
- Permission persistence per scope
- Quick permission override
- Tool execution timing
- Error handling with retry options
- Permission precedence rules enforced
- Audit log of all tool executions

## Technical Requirements

### Core Components
```yaml
packages/domain/security_domain/:
  - entities/permission.dart       # Permission entity
  - entities/tool_execution.dart   # Execution trace
  - value_objects/permission_scope.dart  # Scope definitions
  - services/permission_service.dart     # Permission logic

packages/features/tool_execution/:
  - ui/permission_prompt.dart      # Permission dialog
  - ui/execution_panel.dart        # Run steps display
  - ui/tool_details.dart           # Tool I/O viewer
  - bloc/permission_bloc.dart      # Permission state
  - bloc/execution_bloc.dart       # Execution tracking

packages/infrastructure/security/:
  - permission_store.dart          # Permission persistence
  - execution_logger.dart          # Audit logging
  - tool_sandbox.dart              # Safe execution environment
```

### Database Schema Extension
```sql
CREATE TABLE tool_permissions (
  scope_type TEXT NOT NULL,       -- once, session, chat, workflow
  scope_id TEXT NOT NULL,
  tool_id TEXT NOT NULL,
  decision TEXT NOT NULL,          -- allow, deny
  reason TEXT,
  expires_at INTEGER,
  created_at INTEGER NOT NULL,
  PRIMARY KEY (scope_type, scope_id, tool_id)
);

CREATE TABLE tool_executions (
  id TEXT PRIMARY KEY,
  message_id TEXT NOT NULL,
  tool_id TEXT NOT NULL,
  started_at INTEGER NOT NULL,
  completed_at INTEGER,
  duration_ms INTEGER,
  status TEXT NOT NULL,            -- pending, running, success, error
  input_json TEXT NOT NULL,
  output_json TEXT,
  error TEXT,
  permission_scope TEXT,
  FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE,
  FOREIGN KEY (tool_id) REFERENCES tools(id)
);

CREATE TABLE sessions (
  id TEXT PRIMARY KEY,
  created_at INTEGER NOT NULL,
  ended_at INTEGER,
  active BOOLEAN DEFAULT TRUE
);
```

### Permission Service
```dart
enum PermissionScope {
  deny,        // Highest precedence - blocks
  once,        // Single use
  session,     // Until app restart
  chat,        // For specific chat
  workflow,    // For workflow globally
}

class PermissionService {
  Future<PermissionDecision> checkPermission(
    Tool tool,
    String chatId,
    String? workflowId,
  ) async {
    // Check precedence: Deny > Once > Session > Chat > Workflow
    
    // 1. Check for explicit deny
    if (await _hasDeny(tool.id)) {
      return PermissionDecision.denied('Explicitly denied');
    }
    
    // 2. Check for allow once
    final once = await _consumeOnce(tool.id);
    if (once != null) {
      return PermissionDecision.allowed(PermissionScope.once);
    }
    
    // 3. Check session permissions
    if (await _hasSessionPermission(tool.id)) {
      return PermissionDecision.allowed(PermissionScope.session);
    }
    
    // 4. Check chat permissions
    if (await _hasChatPermission(tool.id, chatId)) {
      return PermissionDecision.allowed(PermissionScope.chat);
    }
    
    // 5. Check workflow permissions
    if (workflowId != null && await _hasWorkflowPermission(tool.id, workflowId)) {
      return PermissionDecision.allowed(PermissionScope.workflow);
    }
    
    // 6. No permission - prompt user
    return PermissionDecision.needsPrompt();
  }
}
```

### Permission Prompt UI
```dart
class PermissionPrompt extends StatelessWidget {
  final Tool tool;
  final Map<String, dynamic> proposedInput;
  
  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text('Tool Permission Request'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text('${tool.name} wants to:'),
          Text(tool.description),
          ExpansionTile(
            title: Text('View Input'),
            children: [JsonViewer(proposedInput)],
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => _decide(PermissionScope.deny),
          child: Text('Deny'),
        ),
        TextButton(
          onPressed: () => _decide(PermissionScope.once),
          child: Text('Allow Once'),
        ),
        TextButton(
          onPressed: () => _decide(PermissionScope.session),
          child: Text('Allow This Session'),
        ),
        TextButton(
          onPressed: () => _decide(PermissionScope.chat),
          child: Text('Allow For Chat'),
        ),
        TextButton(
          onPressed: () => _decide(PermissionScope.workflow),
          child: Text('Always Allow'),
        ),
      ],
    );
  }
}
```

### Execution Trace Panel
```dart
class ExecutionTracePanel extends StatelessWidget {
  final List<ToolExecution> executions;
  
  @override
  Widget build(BuildContext context) {
    return ExpansionPanelList(
      children: executions.map((execution) {
        return ExpansionPanel(
          headerBuilder: (context, isExpanded) {
            return ListTile(
              leading: _statusIcon(execution.status),
              title: Text(execution.tool.name),
              subtitle: Text('${execution.duration}ms'),
              trailing: Text(execution.permissionScope.name),
            );
          },
          body: Padding(
            padding: EdgeInsets.all(16),
            children: [
              _buildIOSection('Input', execution.input),
              _buildIOSection('Output', execution.output),
              if (execution.error != null)
                _buildErrorSection(execution.error!),
            ],
          ),
        );
      }).toList(),
    );
  }
}
```

## Implementation Plan

### Week 1: Permission System
1. Design permission data model
2. Implement permission service
3. Build permission prompt UI
4. Add permission persistence
5. Test precedence rules

### Week 2: Execution Tracking
1. Create execution logger
2. Build trace panel UI
3. Add tool sandboxing
4. Implement audit logging
5. Test with various tools

## Out of Scope (for this PRD)
- Custom permission policies
- Role-based access control
- Tool marketplace
- Custom tool creation
- Advanced sandboxing
- Tool composition
- Batch tool operations
- Tool versioning

## Dependencies
- PRD-01-06 complete
- Tool discovery from backends
- Session management implemented

## What This Enables for Future PRDs
- Safe workflow execution (PRD-08)
- Custom tool policies
- Enterprise security features
- Compliance and auditing

## Acceptance Tests
1. **Permission Prompt Test**: Tool execution → Prompt appears → User decides
2. **Scope Test**: Allow for session → Works until restart → Then prompts again
3. **Deny Test**: Deny tool → Subsequent calls blocked → Override possible
4. **Trace Test**: Execute 5 tools → All visible in panel with I/O
5. **Precedence Test**: Chat allow + Session deny → Deny wins
6. **Audit Test**: Check logs → All executions recorded with decisions

## Security Requirements
- No tool execution without permission
- Clear description of tool capabilities
- Input validation before execution
- Output sanitization
- Secure storage of permissions
- Audit trail cannot be modified
- Session cleanup on app close

## Definition of Done
- [ ] 5-level permission system implemented
- [ ] Permission prompt UI complete
- [ ] Execution trace panel working
- [ ] Permission persistence per scope
- [ ] Session management integrated
- [ ] Audit logging functional
- [ ] Tool I/O display collapsible
- [ ] Error handling with retry
- [ ] Precedence rules enforced
- [ ] Security tests passing
- [ ] Performance tests passing
- [ ] Documentation complete