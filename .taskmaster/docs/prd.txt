# Tina AI Assistant - Product Requirements Document

## Overview

Tina is a Flutter-based AI assistant application designed to provide an intuitive, conversation-driven interface for users to interact with large language models. The application emphasizes simplicity, flexibility, and extensibility while maintaining a polished user experience across multiple platforms.

## Product Vision

Create a seamless AI conversation platform that allows users to:
- Engage in natural, context-aware conversations with AI
- Switch between different AI providers and models
- Maintain persistent conversation history
- Access their AI assistant across mobile and desktop platforms

## Core Features

### 1. Chat Interface
**User Stories:**
- As a user, I want to have natural conversations with an AI assistant
- As a user, I want to see conversation history in an intuitive chat format
- As a user, I want to easily distinguish between my messages and AI responses

**Acceptance Criteria:**
- Clean, modern chat UI with message bubbles
- Support for text-based conversations
- Real-time message display during AI response generation
- Proper handling of long messages and code blocks
- Message timestamps and status indicators

### 2. Multi-Chat Management
**User Stories:**
- As a user, I want to organize conversations into separate chats
- As a user, I want to easily switch between different conversation topics
- As a user, I want to create new chats for different purposes

**Acceptance Criteria:**
- List view of all conversations with titles and previews
- Ability to create, rename, and delete chats
- Automatic chat titling based on conversation content
- Search functionality across all chats

### 3. Backend Management
**User Stories:**
- As a user, I want to choose from different backend types (LLM, Orchestrator, MCP)
- As a user, I want to configure API keys and settings for each backend
- As a user, I want to switch between different models and workflows

**Acceptance Criteria:**
- Backend configuration screen with secure credential vault
- Model selection for LLM backends (OpenAI, Anthropic, etc.)
- Orchestrator setup for n8n/Flowise/Sim Studio
- MCP server discovery and registration
- Connection testing with visual feedback

### 4. Streaming Responses
**User Stories:**
- As a user, I want to see AI responses appear in real-time
- As a user, I want visual feedback that the AI is processing my request

**Acceptance Criteria:**
- Real-time token streaming from AI providers
- Loading indicators and typing animations
- Graceful handling of interrupted streams
- Stop generation functionality

### 5. Persistent Storage
**User Stories:**
- As a user, I want my conversations to be saved locally
- As a user, I want to access my chat history across app sessions
- As a user, I want my provider settings to be remembered

**Acceptance Criteria:**
- Local SQLite database for chat storage
- Secure storage for API keys and sensitive data
- Data export/import functionality
- Automatic backups and data recovery

## Technical Architecture

### Enhanced Architecture: Backends, Tools & Workflows

#### Taxonomy & Concepts
**Backend Types** (where inference runs):
- **LLM Backend**: OpenAI, OpenRouter, Anthropic, Gemini
- **Orchestrator**: n8n, Flowise, Sim Studio (chain tools/agents with SSE/JSONL)
- **MCP Server**: Remote servers via HTTP/SSE with JSON-RPC 2.0

**Core Concepts**:
- **Tool**: Invocable capability (memory, search, web) from host/orchestrator/MCP
- **Workflow**: Reusable Backend + Tools + Policies + Credentials
- **Policy**: Permission levels (Allow once, session, chat, workflow, or Deny)
- **Session**: UI lifecycle scope (cleared on app close/reset)

#### Package Dependencies

**Core Package Stack**:
```yaml
dependencies:
  # Streaming & protocols
  flutter_client_sse: ^2.0.0        # Single SSE client abstraction
  json_rpc_2: ^3.0.2                # MCP JSON-RPC 2.0
  json_schema: ^5.1.0               # Tool schema validation
  
  # Database with FTS5
  drift: ^2.14.1                    # Type-safe SQLite layer
  sqlite3_flutter_libs: ^0.5.15    # Native SQLite with FTS5
  
  # Security
  flutter_secure_storage: ^9.0.0   # Credential vault
  
  # HTTP & state
  dio: ^5.3.3                       # HTTP with interceptors
  flutter_riverpod: ^2.4.9          # State management
  
  # Testing
  integration_test:                 # Modern integration testing
  patrol: ^2.6.0                    # Enhanced test runner
```

### Enhanced Data Model

**Core Tables**:
- `backends`: id, type ∈ {llm, orchestrator, mcp}, name, base_url, credential_id, created_at
- `tools`: id, name, source ∈ {builtin, orchestrator, mcp}, backend_id, schema_json, redact_on_export
- `workflows`: id, name, backend_id, created_at, updated_at
- `sessions`: id, created_at, ended_at
- `chats`: id, title, workflow_id, created_at
- `messages`: id, chat_id, role, content TEXT (FTS5), tool_trace_json, backend_id, backend_type, backend_params_json, created_at

**Relation Tables** (with constraints):
- `workflow_tools`: workflow_id, tool_id, enabled, policy_override_json (UNIQUE composite)
- `workflow_credentials`: workflow_id, credential_id, scope
- `tool_permissions`: scope_type, scope_id, tool_id, decision, expires_at, created_at (PRIMARY KEY: scope_type, scope_id, tool_id)

**Backend Configuration**:
- `llm_options`: backend_id, provider, model, params_json
- `orchestrators`: backend_id, platform, stream_format ∈ {sse, jsonl}
- `mcp_servers`: backend_id, url, headers_json

**Security & Storage**:
- `credentials`: id, name, type, encrypted_secret, allowed_backends_json
- `attachments`: id, message_id, kind, path, metadata_json

**Indices**:
- `messages(chat_id, created_at DESC)`
- `tool_permissions(tool_id, scope_type, scope_id)`
- `workflows(name)` - unique optional
- FTS5 virtual table on `messages(content)` with sync triggers

### Current Implementation Status

#### ✅ Implemented Components:
- **Models**: Data models with JSON serialization (to be extended)
- **State Management**: Riverpod providers for reactive state
- **Services**: N8nService (to evolve into OrchestratorClient)
- **UI Screens**: Chat interface with provider management
- **Widgets**: Message display and input components

### Recommended Architecture Implementation

#### 1. Backend Architecture (LLM, Orchestrator, MCP)
**Backend Abstraction Layer**
- Unified interface for LLM, Orchestrator, and MCP backends
- SSE/JSONL streaming support across all backend types
- JSON-RPC 2.0 for MCP communication
- Dynamic backend switching with hot-reload capabilities

**Integration Points**:
- **OpenRouter**: Drop-in OpenAI replacement with SSE streaming
- **n8n/Flowise**: Orchestrators with tool chaining and SSE/JSONL
- **MCP Servers**: HTTP/SSE transport for mobile (no stdio)
- **Native LLMs**: Direct API integration (OpenAI, Anthropic, Gemini)

#### 2. Tool & Workflow Management
**Tool Registry**
- Builtin tools (host capabilities)
- Orchestrator tools (from n8n/Flowise workflows)
- MCP tools (discovered via JSON-RPC)
- JSON-Schema validation for all tool inputs

**Workflow System**
- Reusable combinations of Backend + Tools + Policies
- Credential bindings per workflow
- Policy inheritance and overrides
- Session-scoped tool permissions

#### 3. Permission & Security Model
**Permission Precedence** (highest to lowest):
1. Deny (blocks with logged reason)
2. Allow once (single invocation)
3. Allow for session (expires on app close/reset)
4. Allow for chat (persistent per conversation)
5. Allow for workflow (global for workflow)

**Permission Expiry**:
- Session permissions cleared on app close or manual reset
- Once permissions consumed immediately
- Chat/workflow permissions persist until revoked
- All decisions logged in tool_trace_json

**Credential Vault**:
- Encrypted storage with flutter_secure_storage
- Exports exclude secrets (only references)
- Test connection per backend/tool
- Clear data boundaries per backend

#### 4. Streaming & Data Architecture
**Unified Stream Event Contract**:
```json
{
  "type": "start|delta|tool_start|tool_end|error|done",
  "messageId": "...",
  "toolId": "?",
  "source": "builtin|orchestrator|mcp",
  "data": {...},
  "cursor": "...",
  "cost": {"tokensIn": 0, "tokensOut": 0, "usd": 0.0},
  "ts": 1736123456
}
```

**Streaming Resilience**:
- Idempotency tokens per message
- Resume from last chunk (SSE last-event-id)
- Exponential backoff with jitter
- "Recover stream" UI action
- Connection state indicators

**SQLite with FTS5**:
- Messages table with content TEXT for FTS5
- Message provenance (backend_id, type, params) frozen at send time
- Foreign key constraints with CASCADE where appropriate
- Efficient pagination (<100ms for 10k messages)
- Version migration with snapshot testing

**MCP Capability Discovery**:
- Required methods: `tools/list`, `tools/call`, `status/health`
- JSON-Schema mapping to ToolDescriptor
- Capability cache with TTL
- Graceful degradation for missing capabilities

### Architecture Highlights

#### Layered Architecture Benefits
- Clear separation of concerns
- Testable and maintainable codebase
- Platform-agnostic business logic
- Easy feature extension and modification

#### Data Flow Architecture
1. **UI Layer** → User interactions trigger state changes
2. **State Layer** → Providers coordinate business operations
3. **Repository Layer** → Data access with caching strategies
4. **Service Layer** → External API communication
5. **Data Layer** → Persistent storage and retrieval

#### Design Patterns Integration
- **Repository Pattern**: Clean data access abstraction
- **Factory Pattern**: AI provider management
- **Strategy Pattern**: Interchangeable implementations
- **Observer Pattern**: Reactive state management
- **Singleton Pattern**: Shared services and utilities

### Testing Strategy Overview
**Multi-Level Testing Approach**
- Unit tests for business logic and utilities
- Widget tests for UI component validation
- Integration tests for user workflow verification
- Golden file tests for visual regression prevention

**Mock and Stub Strategy**
- Repository mocking for isolated testing
- AI provider stubs for predictable responses
- Database in-memory instances for test isolation
- Network mocking for offline test scenarios

## User Experience Flow

### Primary User Journey
1. **App Launch** → Chat list with existing conversations
2. **New Chat** → Provider selection and chat creation
3. **Conversation** → Message input, streaming responses, persistent history
4. **Chat Management** → Switch chats, organize conversations
5. **Settings** → Configure providers, manage API keys

### Key UI/UX Principles
- **Simplicity**: Minimal, distraction-free interface
- **Responsiveness**: Real-time feedback and smooth animations
- **Accessibility**: Proper contrast, text scaling, screen reader support
- **Cross-platform**: Consistent experience across mobile and desktop

## Platform Support

### Target Platforms
- **Mobile**: iOS and Android (primary focus)
- **Desktop**: Windows, macOS, Linux (secondary)
- **Web**: Progressive web app capability

### Platform-Specific Considerations
- Mobile: Touch-optimized UI, keyboard handling, background processing
- Desktop: Keyboard shortcuts, window management, system integration
- Web: Responsive design, offline capabilities, PWA features

## Performance Requirements

### Response Time Goals
- App startup: < 2 seconds
- Chat loading: < 1 second
- Message send: < 100ms to UI feedback
- AI response streaming: < 500ms to first token

### Resource Efficiency
- Memory usage: < 100MB baseline
- Storage: Efficient chat compression and archival
- Network: Optimized API calls, proper caching
- Battery: Minimal background processing

## Security & Privacy

### Credential Vault
- Encrypted storage with flutter_secure_storage
- Credential scoping with allowed_backends[] validation
- Exports exclude secrets (only references)
- Test connection validation per backend
- BYO API key philosophy

### Data Protection
- Local-first approach: All data on device
- Tool I/O redaction policy (per-tool flag + global export option)
- No telemetry without explicit consent
- Optional E2EE cloud sync (future)
- Per-chat/workflow data isolation

### Cost Controls
**Enforcement Behavior**:
- **Soft limit**: Warning + continue unless user cancels
- **Hard limit**: Block send with "raise limit once" CTA
- Per-chat usage meters (tokens & cost estimates)
- Workflow-level limits with override options
- Cost-saving mode (auto-reduce context window)

## Acceptance Criteria

### Core Functionality
- **Backend switching**: In-chat changes freeze backend_params_json in message for audit trail
- **Run Steps Panel**: Tool name, source, duration, I/O (collapsible), permission decision, errors
- **Permissions**: Five scopes with precedence testing; deny blocks with one-click override
- **Search**: FTS5 returns results across all chats in <100ms on 10k messages
- **Sessions**: First-class table tracking session lifecycle for permission expiry

### Technical Requirements
- **Streaming**: Unified event contract, reconnection with resume via last-event-id
- **MCP Integration**: Capability discovery (tools/list, tools/call, status/health)
- **Data Integrity**: Foreign keys with CASCADE, composite keys, proper indices
- **Security**: Credential scoping, redaction policies, test connection validation
- **Accessibility**: Virtualization for long chats, screen reader labels

### Testing Priorities
- **Permission precedence**: Property-based tests for Deny > Once > Session > Chat > Workflow
- **Migration tests**: Snapshot DB v1→vN with sample data validation
- **Stream recovery**: Kill SSE mid-response, verify resume without duplication
- **Cost enforcement**: Soft/hard limit behavior verification

## Success Metrics

### User Engagement
- Daily active users and session duration
- Messages per conversation depth
- Backend/tool usage distribution
- Permission grant/deny ratios

### Technical Performance
- App crash rate: < 0.1%
- Stream success rate: > 99.5%
- Search query time: < 100ms
- Tool invocation latency: < 500ms

## Development Roadmap

### Sprint A: Unify & Stream
**Deliverables**:
- BackendClient adapters (LLM/Orchestrator SSE-JSONL/MCP HTTP-SSE)
- Unified stream event contract with normalization
- Permission prompts (5 scopes) with precedence store
- Run Steps panel (collapsible I/O, errors, timings)
- Credential vault MVP with "Test connection"
- Message provenance snapshot (backend_params_json)

### Sprint B: Workflows & Governance
**Deliverables**:
- Relation tables with foreign keys, indices, migrations
- Sessions table wired to permission expiry
- Workflow picker with backend override badges
- Usage meters with soft/hard limit enforcement
- Export without secrets + optional I/O redaction
- Accessibility improvements (virtualization, labels)

### Phase 1: Core MVP (Current Status)
- ✅ Basic chat interface and message handling
- ✅ Initial backend integration (n8n)
- ✅ Local storage and persistence
- ✅ Multi-chat management

### Phase 2: Backend & Tool Integration
**Packages to implement:**
- `flutter_client_sse: ^2.0.0` - SSE streaming for orchestrators
- `json_rpc_2: ^3.0.2` - MCP server communication
- `json_schema: ^5.1.0` - Tool schema validation
- `flutter_markdown: ^0.6.18` - Rich message formatting

**Implementation focus:**
- Multi-backend support (LLM, Orchestrator, MCP)
- Tool discovery and registration
- Permission prompts with scoped persistence
- Tool trace panel with step visualization

### Phase 3: Workflow & Orchestration
**Packages to implement:**
- `drift: ^2.14.1` with FTS5 - Full-text search capabilities
- `flutter_secure_storage: ^9.0.0` - Credential vault
- Integration with n8n, Flowise, Sim Studio orchestrators
- MCP server discovery and registration

**Implementation focus:**
- Workflow designer with drag-drop interface
- Credential management vault
- Policy editor with granular permissions
- Batch operations and workflow templates

### Phase 4: Advanced Platform Features
**Implementation focus:**
- Desktop/Web platform expansion
- Multi-modal support (images, documents)
- Advanced MCP capabilities (complex tools)
- E2EE sync across devices
- Plugin system for extensibility

## Implementation Guidelines & Best Practices

### Project Structure Strategy
**Clean Architecture Organization**
```
lib/
├── core/                          # Shared utilities and constants
├── data/                          # Data layer implementations
├── domain/                        # Business logic and entities
├── presentation/                  # UI components and screens  
├── services/                      # External service integrations
└── providers/                     # State management providers
```

**Layer Responsibilities**
- **Core**: Cross-cutting concerns, utilities, constants
- **Data**: Repository implementations, database, network
- **Domain**: Business entities, use cases, repository contracts
- **Presentation**: Widgets, screens, themes, platform UI
- **Services**: AI providers, storage, external integrations
- **Providers**: Riverpod state management coordination

### Development Workflow Strategy
**Code Generation Approach**
- Automated code generation for models and providers
- Build runner integration for development workflow
- Version control exclusion of generated files
- CI/CD pipeline integration for consistent builds

**Quality Assurance Process**
- Automated linting and code analysis
- Unit test coverage requirements
- Integration test validation
- Performance benchmarking and monitoring

## Technical Debt and Improvements

### Current Areas for Enhancement
**Error handling robustness:**
- Implement `dio_exception_handler` for network error management
- Add `flutter_error_boundary` for graceful error recovery
- Use `logging: ^1.2.0` for structured error reporting

**UI polish and animations:**
- Integrate `animations: ^2.0.8` for Material motion
- Add `lottie: ^2.7.0` for loading animations
- Implement `shimmer: ^3.0.0` for skeleton loading states

**Testing coverage expansion:**
- Set up `mocktail: ^1.0.1` for comprehensive mocking
- Use `golden_toolkit: ^0.15.0` for visual regression testing
- Implement `patrol: ^2.6.0` for integration testing

**Performance optimization:**
- Add `flutter_performance_monitor` for runtime metrics
- Implement lazy loading with `infinite_scroll_pagination`
- Use `cached_network_image` for efficient image handling

**Accessibility improvements:**
- Implement semantic labels and screen reader support
- Add high contrast theme support
- Ensure keyboard navigation compatibility

### Code Quality Goals
**Comprehensive testing strategy:**
- Unit tests for all business logic and utilities
- Widget tests for UI component validation
- Integration tests for complete user workflows
- Golden file tests for visual regression detection
- Mock-based testing for external dependencies

**Consistent code formatting:**
- Flutter linting rules enforcement
- Automated code analysis with metrics
- Pre-commit hooks for code quality
- Generated code exclusion from analysis
- Consistent import organization and structure

**Documentation improvements:**
- Generate API documentation with `dartdoc`
- Maintain architecture decision records (ADRs)
- Create developer onboarding guides with code examples
- Document AI provider integration patterns

**Architecture pattern refinement:**
- Implement Clean Architecture layers consistently
- Use dependency injection throughout the application
- Apply SOLID principles in service design
- Establish clear separation of concerns between layers

## Risk Assessment

### Technical Risks
- **AI Provider Dependencies**: Mitigated by multi-provider support
- **Platform Fragmentation**: Addressed by Flutter's cross-platform capabilities
- **Data Migration**: Handled by versioned storage schemas
- **Performance Scaling**: Managed through efficient data structures and caching

### Business Risks
- **AI Provider Costs**: User-managed API keys transfer cost responsibility
- **Competition**: Focus on unique UX and flexibility
- **Privacy Regulations**: Local-first approach reduces compliance complexity

## Open Source & Licensing

### License
This project is licensed under the **MIT License** - a permissive open-source license that allows:
- Commercial use
- Modification and distribution
- Private use
- Liability limitation

### Open Source Philosophy
- **BYO API Keys**: Users maintain control of their AI service costs
- **Self-hostable backends**: Support for local/private orchestrators
- **Extensible architecture**: Plugin points for community contributions
- **Privacy-first**: No vendor lock-in or data collection

### Community & Contributions
- Public repository with clear contribution guidelines
- Modular design for third-party backend integrations
- Extension points for custom tools and workflows
- Documentation for self-hosted deployments

## Conclusion

Tina represents a well-architected, user-focused AI assistant application with a solid foundation for growth and enhancement. The current implementation demonstrates thoughtful technical decisions, clean code organization, and a clear path forward for feature development.

The combination of Flutter's cross-platform capabilities, Riverpod's reactive state management, and a flexible backend system (LLM/Orchestrator/MCP) positions Tina as a competitive and extensible solution in the AI assistant space.

The MIT license ensures the project remains open and accessible, fostering community contributions while enabling commercial use cases. Future development should focus on UI/UX polish, performance optimization, and strategic feature additions that enhance the core conversation experience while maintaining the application's simplicity, privacy, and reliability principles.



# Tina AI Assistant - Monorepo Architecture Guide

## Executive Summary

This document synthesizes insights from 8 different architectural analyses to define the optimal monorepo structure for the Tina AI Assistant project. After comprehensive evaluation, we recommend a **Hybrid Architecture** that combines the best aspects of Clean Architecture, Domain-Driven Design, and Hexagonal Architecture, organized in a layered-modular structure with plugin capabilities.

## Architecture Overview

### Core Principles
1. **Domain-Centric Design**: Business logic at the center, independent of frameworks
2. **Port & Adapter Pattern**: Clear interfaces between core and external systems
3. **Layered Modularity**: Horizontal technical layers with vertical feature modules
4. **Plugin Extensibility**: Support for third-party extensions and customizations
5. **Event-Driven Communication**: Loose coupling between components via events

## Recommended Package Structure

```
tina/
├── apps/
│   ├── tina_shell/                  # Main Flutter application shell
│   └── tina_desktop/                 # Desktop-specific wrapper (future)
│
├── packages/
│   ├── core/                        # Shared utilities and infrastructure
│   │   ├── tina_core/               # Common types, constants, extensions
│   │   ├── tina_contracts/          # Shared interfaces and protocols
│   │   ├── tina_events/             # Event bus and domain events
│   │   ├── tina_logging/            # Structured logging infrastructure
│   │   └── tina_testing/            # Test utilities and mocks
│   │
│   ├── domain/                      # Business logic (pure Dart, no Flutter)
│   │   ├── chat_domain/             # Chat entities, value objects, aggregates
│   │   ├── backend_domain/          # Backend management business logic
│   │   ├── tool_domain/             # Tool entities and execution logic
│   │   ├── workflow_domain/         # Workflow entities and orchestration
│   │   └── security_domain/         # Credentials, permissions, policies
│   │
│   ├── application/                 # Use cases and application services
│   │   ├── chat_application/        # Chat-related use cases
│   │   ├── backend_application/     # Backend management use cases
│   │   ├── tool_application/        # Tool execution use cases
│   │   ├── workflow_application/    # Workflow orchestration use cases
│   │   └── security_application/    # Authentication/authorization use cases
│   │
│   ├── infrastructure/              # External system integrations
│   │   ├── database/                # Drift database implementation
│   │   │   ├── tina_database/       # Core database with FTS5
│   │   │   └── tina_migrations/     # Database migration management
│   │   │
│   │   ├── providers/               # AI provider implementations
│   │   │   ├── openai_provider/     # OpenAI API integration
│   │   │   ├── anthropic_provider/  # Anthropic Claude integration
│   │   │   ├── gemini_provider/     # Google Gemini integration
│   │   │   └── openrouter_provider/ # OpenRouter integration
│   │   │
│   │   ├── orchestrators/           # Workflow orchestrator clients
│   │   │   ├── n8n_client/          # n8n integration with SSE
│   │   │   ├── flowise_client/      # Flowise integration
│   │   │   └── sim_studio_client/   # Sim Studio integration
│   │   │
│   │   ├── integrations/            # External service integrations
│   │   │   ├── mcp_client/          # MCP server JSON-RPC client
│   │   │   ├── storage_service/     # Secure storage implementation
│   │   │   └── notification_service/# System notifications
│   │   │
│   │   └── network/                 # Network layer
│   │       ├── http_client/         # Dio HTTP client configuration
│   │       ├── sse_client/          # Server-sent events client
│   │       └── websocket_client/    # WebSocket client (future)
│   │
│   ├── presentation/                # Shared UI components and utilities
│   │   ├── design_system/           # Widgetbook design system
│   │   │   ├── tokens/              # Design tokens (colors, spacing)
│   │   │   ├── components/          # Reusable UI components
│   │   │   └── themes/              # Theme configurations
│   │   │
│   │   ├── routing/                 # go_router configuration
│   │   ├── state/                   # Shared state management (Bloc/Riverpod)
│   │   └── widgets/                 # Common Flutter widgets
│   │
│   └── features/                    # Feature-specific implementations
│       ├── chat/                    # Chat feature module
│       │   ├── ui/                  # Chat screens and widgets
│       │   ├── bloc/                # Chat state management
│       │   └── adapters/            # Chat-specific adapters
│       │
│       ├── backend_management/      # Backend configuration feature
│       │   ├── ui/                  # Backend management screens
│       │   ├── bloc/                # Backend state management
│       │   └── adapters/            # Backend-specific adapters
│       │
│       ├── tool_execution/          # Tool execution feature
│       │   ├── ui/                  # Tool UI components
│       │   ├── bloc/                # Tool state management
│       │   └── adapters/            # Tool-specific adapters
│       │
│       └── workflow_designer/       # Workflow design feature
│           ├── ui/                  # Workflow designer UI
│           ├── bloc/                # Workflow state management
│           └── adapters/            # Workflow-specific adapters
│
├── plugins/                         # Optional plugin packages
│   ├── example_tool_plugin/        # Example tool plugin
│   └── example_theme_plugin/       # Example theme plugin
│
└── tools/                           # Development tools
    ├── mason_bricks/                # Mason templates
    ├── code_generation/             # Code generation scripts
    └── scripts/                     # Build and deployment scripts
```

## Package Dependencies

### Dependency Rules
1. **Domain packages** have NO external dependencies (pure Dart)
2. **Application packages** depend only on domain packages
3. **Infrastructure packages** depend on domain and external libraries
4. **Feature packages** can depend on all layers but not on each other
5. **Core packages** can be used by any package

### Dependency Flow
```
Features → Application → Domain ← Infrastructure
    ↓           ↓          ↓           ↓
    └───────────── Core ────────────────┘
```

## Package Specifications

### Core Packages

#### `tina_core`
**Purpose**: Shared utilities, constants, and base classes
**Dependencies**: None (pure Dart)
**Key Components**:
- Result type for error handling
- Common exceptions and failures
- Extension methods
- Constants and enums
- Base use case interface

#### `tina_contracts`
**Purpose**: Shared interfaces and contracts
**Dependencies**: `tina_core`
**Key Components**:
- Port interfaces (primary and secondary)
- Event contracts
- Stream event definitions
- Plugin interfaces
- Service contracts

#### `tina_events`
**Purpose**: Event-driven architecture support
**Dependencies**: `rxdart`, `tina_core`
**Key Components**:
- Event bus implementation
- Domain event base classes
- Event aggregator
- Event replay mechanisms
- Event sourcing support

### Domain Packages

#### `chat_domain`
**Purpose**: Chat business logic and entities
**Dependencies**: None (pure Dart)
**Key Components**:
- Chat aggregate root
- Message entities and value objects
- Chat repository interface
- Business rules and invariants
- Domain events (MessageSent, ChatCreated, etc.)

#### `backend_domain`
**Purpose**: Backend management domain logic
**Dependencies**: None (pure Dart)
**Key Components**:
- Backend entity and value objects
- Backend types (LLM, Orchestrator, MCP)
- Configuration value objects
- Backend repository interface
- Backend capability definitions

#### `tool_domain`
**Purpose**: Tool execution domain logic
**Dependencies**: None (pure Dart)
**Key Components**:
- Tool entity and metadata
- Tool execution context
- Permission value objects
- Tool repository interface
- Tool discovery interface

### Infrastructure Packages

#### `tina_database`
**Purpose**: Drift database implementation with FTS5
**Dependencies**: `drift`, `sqlite3_flutter_libs`, domain packages
**Key Components**:
- Database schema definition
- DAO implementations
- Repository implementations
- Migration management
- Full-text search implementation

#### Provider Packages (OpenAI, Anthropic, etc.)
**Purpose**: AI provider integrations
**Dependencies**: `dio`, `flutter_client_sse`, domain packages
**Key Components**:
- Provider-specific API clients
- Streaming response handlers
- Model configuration
- Error handling and retry logic
- Token counting utilities

### Feature Packages

#### `chat` Feature
**Purpose**: Complete chat functionality
**Dependencies**: All layers, `bloc`, `go_router`
**Key Components**:
- Chat list screen
- Conversation screen
- Message input widget
- Streaming message display
- Chat BLoC/Cubit
- Feature-specific adapters

## Technology Stack

### Core Dependencies
```yaml
dependencies:
  # State Management
  flutter_bloc: ^8.1.3
  flutter_riverpod: ^2.4.9
  
  # Database
  drift: ^2.14.1
  sqlite3_flutter_libs: ^0.5.15
  
  # Networking
  dio: ^5.3.3
  retrofit: ^4.0.3
  flutter_client_sse: ^2.0.0
  json_rpc_2: ^3.0.2
  
  # Code Generation
  freezed_annotation: ^2.4.1
  json_annotation: ^4.8.1
  
  # Routing
  go_router: ^12.1.3
  
  # UI/Design System
  widgetbook: ^3.7.0
  flutter_gen: ^5.3.2
  
  # Security
  flutter_secure_storage: ^9.0.0
  
  # Utilities
  rxdart: ^0.27.7
  envied: ^0.5.2
  get_it: ^7.6.4
  injectable: ^2.3.2
  
dev_dependencies:
  # Code Generation
  build_runner: ^2.4.7
  freezed: ^2.4.6
  json_serializable: ^6.7.1
  drift_dev: ^2.14.1
  retrofit_generator: ^8.0.6
  
  # Testing
  flutter_test:
  mocktail: ^1.0.1
  bloc_test: ^9.1.5
  
  # Linting
  very_good_analysis: ^5.1.0
  
  # Development Tools
  mason: ^0.1.0-dev.51
  melos: ^3.4.0
```

## Implementation Patterns

### 1. Repository Pattern
```dart
// Domain layer - interface
abstract class ChatRepository {
  Future<Result<Chat>> getChat(ChatId id);
  Future<Result<List<Chat>>> getAllChats();
  Future<Result<Chat>> createChat(CreateChatParams params);
  Future<Result<Unit>> deleteChat(ChatId id);
}

// Infrastructure layer - implementation
class DriftChatRepository implements ChatRepository {
  final TinaDatabase _database;
  
  @override
  Future<Result<Chat>> getChat(ChatId id) async {
    try {
      final data = await _database.chatDao.findById(id.value);
      return Success(ChatMapper.toDomain(data));
    } catch (e) {
      return Failure(DatabaseFailure(e.toString()));
    }
  }
}
```

### 2. Use Case Pattern
```dart
class SendMessageUseCase {
  final ChatRepository _chatRepository;
  final BackendService _backendService;
  final EventBus _eventBus;
  
  Future<Result<Message>> execute(SendMessageParams params) async {
    // Validate input
    final validationResult = params.validate();
    if (validationResult.isFailure) return validationResult;
    
    // Get chat
    final chatResult = await _chatRepository.getChat(params.chatId);
    if (chatResult.isFailure) return chatResult.mapFailure();
    
    // Create and save message
    final message = Message.create(
      chatId: params.chatId,
      content: params.content,
      role: MessageRole.user,
    );
    
    // Publish event
    await _eventBus.publish(MessageSentEvent(message));
    
    // Get AI response (streaming)
    await _backendService.streamResponse(message);
    
    return Success(message);
  }
}
```

### 3. BLoC Pattern
```dart
class ChatBloc extends Bloc<ChatEvent, ChatState> {
  final SendMessageUseCase _sendMessageUseCase;
  final GetChatHistoryUseCase _getChatHistoryUseCase;
  
  ChatBloc({
    required SendMessageUseCase sendMessageUseCase,
    required GetChatHistoryUseCase getChatHistoryUseCase,
  }) : _sendMessageUseCase = sendMessageUseCase,
       _getChatHistoryUseCase = getChatHistoryUseCase,
       super(ChatInitial()) {
    on<SendMessage>(_onSendMessage);
    on<LoadChatHistory>(_onLoadChatHistory);
  }
  
  Future<void> _onSendMessage(
    SendMessage event,
    Emitter<ChatState> emit,
  ) async {
    emit(ChatSending());
    
    final result = await _sendMessageUseCase.execute(
      SendMessageParams(
        chatId: event.chatId,
        content: event.content,
      ),
    );
    
    result.fold(
      (failure) => emit(ChatError(failure.message)),
      (message) => emit(ChatMessageSent(message)),
    );
  }
}
```

### 4. Adapter Pattern
```dart
// Port definition
abstract class AIServicePort {
  Future<Result<StreamController<String>>> streamCompletion(
    BackendId backendId,
    List<Message> messages,
  );
}

// Adapter implementation
class OpenAIAdapter implements AIServicePort {
  final OpenAIClient _client;
  
  @override
  Future<Result<StreamController<String>>> streamCompletion(
    BackendId backendId,
    List<Message> messages,
  ) async {
    try {
      final controller = StreamController<String>();
      
      _client.streamChat(
        messages: messages.map((m) => m.toOpenAIFormat()).toList(),
        onData: (chunk) => controller.add(chunk),
        onDone: () => controller.close(),
        onError: (error) => controller.addError(error),
      );
      
      return Success(controller);
    } catch (e) {
      return Failure(AIServiceFailure(e.toString()));
    }
  }
}
```

## Development Workflow

### 1. Package Creation
```bash
# Create a new domain package
melos exec --scope="tina_*" -- flutter create --template=package .

# Generate package structure
mason make package_template \
  --name=new_domain \
  --type=domain \
  --output=packages/domain/
```

### 2. Code Generation
```bash
# Run build_runner for all packages
melos run build

# Watch mode for development
melos run watch

# Generate for specific package
melos exec --scope="chat_domain" -- flutter pub run build_runner build
```

### 3. Testing Strategy
```bash
# Run all tests
melos run test

# Run tests with coverage
melos run coverage

# Run specific package tests
melos exec --scope="chat_domain" -- flutter test
```

## Migration Roadmap

### Phase 1: Foundation (Weeks 1-2)
1. Set up monorepo structure with Melos
2. Create core packages (tina_core, tina_contracts, tina_events)
3. Define domain entities and value objects
4. Set up CI/CD pipeline

### Phase 2: Domain & Application (Weeks 3-4)
1. Implement domain packages (chat, backend, tool, workflow, security)
2. Create application layer use cases
3. Define repository interfaces
4. Set up event bus and domain events

### Phase 3: Infrastructure (Weeks 5-6)
1. Implement database package with Drift
2. Create AI provider adapters (OpenAI, Anthropic)
3. Build orchestrator clients (n8n, Flowise)
4. Implement MCP client

### Phase 4: Features (Weeks 7-8)
1. Migrate existing UI to feature packages
2. Implement BLoC state management
3. Connect features to application layer
4. Set up routing with go_router

### Phase 5: Polish & Optimization (Weeks 9-10)
1. Implement Widgetbook design system
2. Add comprehensive testing
3. Performance optimization
4. Documentation and examples

## Best Practices

### 1. Dependency Management
- Use `melos` for monorepo management
- Keep dependencies minimal and focused
- Version packages independently
- Use dependency overrides sparingly

### 2. Code Organization
- One class per file (except related small classes)
- Group related functionality in subdirectories
- Use barrel exports for clean imports
- Keep feature packages self-contained

### 3. Testing
- Unit test domain logic thoroughly (>90% coverage)
- Integration test feature flows
- Use mocks for external dependencies
- Test-driven development for complex logic

### 4. Documentation
- Document all public APIs
- Include examples in package README
- Maintain architecture decision records (ADRs)
- Keep dependency diagrams updated

### 5. Code Quality
- Use `very_good_analysis` linting rules
- Enforce formatting with `dart format`
- Regular refactoring sessions
- Code reviews for all changes

## Performance Considerations

### 1. Build Performance
- Use `melos` caching for faster builds
- Selective package building
- Parallel test execution
- Incremental code generation

### 2. Runtime Performance
- Lazy loading of features
- Efficient state management
- Database indexing and FTS5
- Stream processing optimization

### 3. Bundle Size
- Tree shaking for unused code
- Conditional imports for platform-specific code
- Lazy loading of heavy dependencies
- Code splitting for web deployment

## Security Guidelines

### 1. Credential Management
- Never commit API keys or secrets
- Use `flutter_secure_storage` for sensitive data
- Implement proper permission scoping
- Regular security audits

### 2. Data Protection
- Encrypt sensitive data at rest
- Use secure communication channels
- Implement proper authentication
- Follow OWASP guidelines

### 3. Plugin Security
- Sandbox plugin execution
- Validate plugin inputs
- Review third-party plugins
- Implement permission system

## Conclusion

This monorepo architecture provides a scalable, maintainable foundation for the Tina AI Assistant that:

1. **Supports Team Collaboration**: Clear package boundaries enable parallel development
2. **Ensures Code Quality**: Separation of concerns and comprehensive testing
3. **Enables Extensibility**: Plugin architecture and clean interfaces
4. **Maintains Performance**: Optimized build and runtime characteristics
5. **Facilitates Open Source**: Clear structure for community contributions

The architecture balances complexity with pragmatism, providing structure without over-engineering. It positions Tina for growth while maintaining development velocity and code quality.

## Next Steps

1. **Review & Approval**: Review this architecture with stakeholders
2. **Tooling Setup**: Configure Melos and create package templates
3. **MVP Implementation**: Start with core packages and chat feature
4. **Iterative Development**: Build features incrementally
5. **Community Engagement**: Open source with clear contribution guidelines

## Appendices

### A. Package Dependency Graph
```mermaid
graph TD
    A[tina_shell] --> B[Features]
    B --> C[Application Layer]
    B --> D[Presentation Layer]
    C --> E[Domain Layer]
    D --> E
    F[Infrastructure] --> E
    B --> F
    C --> F
    G[Core Packages] --> E
    G --> C
    G --> F
    G --> B
    G --> D
```

### B. Event Flow Diagram
```mermaid
sequenceDiagram
    participant UI
    participant BLoC
    participant UseCase
    participant Repository
    participant EventBus
    participant Backend
    
    UI->>BLoC: Send Message
    BLoC->>UseCase: Execute
    UseCase->>Repository: Save Message
    UseCase->>EventBus: Publish MessageSent
    UseCase->>Backend: Stream Response
    Backend-->>EventBus: Stream Events
    EventBus-->>BLoC: Update State
    BLoC-->>UI: Render Updates
```

### C. Testing Pyramid
```
         /\
        /  \  E2E Tests (5%)
       /____\
      /      \  Integration Tests (20%)
     /________\
    /          \  Widget Tests (25%)
   /____________\
  /              \  Unit Tests (50%)
 /________________\
```

### D. Technology Decision Matrix

| Aspect | Technology | Rationale |
|--------|------------|-----------|
| State Management | BLoC + Riverpod | BLoC for features, Riverpod for global state |
| Database | Drift + SQLite | Type-safe queries, FTS5 support |
| Networking | Dio + Retrofit | Interceptors, code generation |
| Code Generation | Freezed + JsonSerializable | Immutable models, JSON handling |
| Testing | Mocktail | Simple, powerful mocking |
| Routing | go_router | Declarative, type-safe routing |
| Design System | Widgetbook | Component documentation and testing |
| Monorepo | Melos | Flutter-specific tooling |
| Analysis | very_good_analysis | Industry-standard linting |

This architecture guide serves as the definitive reference for building and maintaining the Tina AI Assistant monorepo structure.


- Widgetbook - to build design systems
- Mason - to create and manage code templates
- melos - to manage monorepo project
- FlutterGen - to generate code for assets, fonts, colors, etc. with strong typing
- Mocktail - for mocking in tests
- Codemagic - CI/CD for Flutter apps
- bloc - for state management
- alchemist - for testing and code generation, and generating screenshots of stores
- Retrofit - for networking typesafe HTTP client
- flutter_launcher_icons - for generating app icons
- flutter_native_splash - for creating native splash screens
- shorebird - for deploying Flutter apps
- go_router - for declarative routing
- very_good_analysis - for static analysis and linting
- envied - for managing environment variables
- drift - for reactive persistence

- freezed - for immutable data classes and unions
- json_serializable - for JSON serialization