{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Structure and Dependencies",
        "description": "Configure the Flutter monorepo project structure following the Hybrid Architecture guidelines with proper package separation in packages/ directory, Melos configuration, and DDD/Clean Architecture patterns",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "Following the Hybrid Architecture from docs/monorepo-architecture-guide.md: 1) Update pubspec.yaml in apps/tina_app with chat dependencies (COMPLETED). 2) Create proper monorepo package structure in packages/ directory following the architecture guide: packages/core/tina_core, packages/domain/chat_domain, packages/application/chat_application, packages/infrastructure/, packages/presentation/, packages/features/chat. 3) Remove default counter app code from apps/tina_app/lib/main.dart and setup basic MaterialApp. 4) Configure apps/tina_app to depend on the new packages instead of internal lib/ folders. 5) Verify Melos configuration works with melos bootstrap and code generation with melos run generate. 6) Ensure proper package boundaries and DDD patterns are established following the Hybrid Architecture pattern.",
        "testStrategy": "Verify monorepo structure with melos bootstrap, test package dependencies install correctly with melos exec, validate package structure follows Hybrid Architecture patterns from docs/monorepo-architecture-guide.md, ensure app runs without errors showing basic scaffold, test melos run generate works for code generation, and verify package boundaries are properly established with proper dependency flow",
        "subtasks": [
          {
            "id": 2,
            "title": "Create Core Package Structure",
            "description": "Create packages/core/tina_core package following the Hybrid Architecture with shared utilities, constants, and base classes",
            "status": "done",
            "dependencies": [],
            "details": "Create packages/core/tina_core/ package with pubspec.yaml, lib/src/ structure including common types, constants, extensions, Result type for error handling, and base use case interface following docs/monorepo-architecture-guide.md specifications. This package should have NO external dependencies (pure Dart).\n<info added on 2025-09-11T18:29:09.464Z>\nI'll analyze the codebase to understand the current project structure and then provide the appropriate update for the subtask.IMPLEMENTATION COMPLETED: Successfully created and validated the tina_core package with comprehensive implementation including all core components (Result type, failure classes, use case interfaces, constants, extensions, UUID generator), complete test suite covering all functionality, proper package structure following Clean Architecture principles, comprehensive documentation, and successful validation through testing and static analysis.\n</info added on 2025-09-11T18:29:09.464Z>",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Domain Package for Chat",
            "description": "Create packages/domain/chat_domain package with pure Dart business logic following DDD principles",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Create packages/domain/chat_domain/ with entities, value objects, repository interfaces, and domain events. Include Message entity, MessageRole and MessageStatus enums, Chat aggregate root, and ChatRepository interface. Package should only depend on tina_core and have no Flutter dependencies.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Application Layer Package",
            "description": "Create packages/application/chat_application package with use cases and application services",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "Create packages/application/chat_application/ with use cases for SendMessage, LoadChatHistory, and other chat operations. Should depend only on chat_domain and tina_core packages following the dependency rules from the architecture guide.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create Infrastructure Packages",
            "description": "Create infrastructure packages for external integrations following the architecture guide structure",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "Create packages/infrastructure/providers/openai_provider and packages/infrastructure/network/http_client packages. These should implement repository interfaces from domain layer and handle external API communications with proper dependency injection.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create Presentation and Feature Packages",
            "description": "Create packages/presentation/design_system and packages/features/chat packages for UI components and feature-specific implementations",
            "status": "pending",
            "dependencies": [
              4,
              5
            ],
            "details": "Create packages/presentation/design_system for shared UI components and packages/features/chat for chat-specific screens, widgets, and BLoC state management. Chat feature should depend on all layers following the architecture dependency flow.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Update App Dependencies and Clean Counter Code",
            "description": "Update apps/tina_app to use new packages and remove default Flutter counter app code",
            "status": "pending",
            "dependencies": [
              6
            ],
            "details": "Update apps/tina_app/pubspec.yaml to depend on the new packages instead of implementing everything in lib/ folders. Remove default counter app implementation from main.dart and replace with basic MaterialApp setup that uses the new package structure.",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Verify Melos Bootstrap and Code Generation",
            "description": "Test monorepo configuration and ensure all package dependencies work correctly with melos commands",
            "status": "pending",
            "dependencies": [
              7
            ],
            "details": "Execute melos bootstrap to verify workspace structure, run melos run generate to test code generation across packages, and ensure all package dependencies are resolved correctly following the workspace setup in pubspec.yaml.",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Validate Hybrid Architecture Implementation",
            "description": "Ensure proper package boundaries and dependency flow following the Hybrid Architecture pattern",
            "status": "pending",
            "dependencies": [
              8
            ],
            "details": "Review and validate that the created package structure properly implements the Hybrid Architecture from docs/monorepo-architecture-guide.md with correct dependency flow: Features → Application → Domain ← Infrastructure, with Core packages used by all layers. Verify no circular dependencies exist.",
            "testStrategy": ""
          },
          {
            "id": 1,
            "title": "Update pubspec.yaml Dependencies",
            "description": "Add missing chat-related dependencies to apps/tina_app/pubspec.yaml including flutter_bloc ^8.1.6, dio ^5.7.0, flutter_markdown ^0.7.4, and equatable ^2.0.7",
            "dependencies": [],
            "details": "Update the pubspec.yaml file in apps/tina_app to include the required dependencies for chat functionality. Verify that uuid ^4.5.1 already exists and add the new dependencies with correct version constraints.\n<info added on 2025-09-11T18:03:40.888Z>\nI'll analyze the codebase first to understand the current project structure and then provide the update for the subtask.Based on my analysis of the codebase, I can see that the AGENTS.md file has been updated with comprehensive dependency management guidelines using `flutter pub add` commands, and the pubspec.yaml in apps/tina_app already contains all the required chat dependencies with the correct versions mentioned in the user request.\n\nThe AGENTS.md file now includes proper command-line instructions for dependency management (lines 17-33) and the pubspec.yaml shows that the dependencies have been properly added:\n- flutter_bloc: ^9.1.1 \n- dio: ^5.9.0\n- flutter_markdown: ^0.7.7+1\n- equatable: ^2.0.7\n\nAll dependencies are properly organized with comments and follow the recommended approach outlined in the updated AGENTS.md documentation.\n</info added on 2025-09-11T18:03:40.888Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Create Core Data Models",
        "description": "Implement Message model and related enums for chat functionality following DDD principles as Value Objects with proper validation and json_serializable integration",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Following the Hybrid Architecture from /docs/monorepo-architecture-guide.md, implement domain models as Value Objects in lib/features/chat/domain/entities/message.dart and lib/features/chat/domain/value_objects/ for MessageRole and MessageStatus enums. Create Message as immutable Value Object with proper validation using freezed and json_serializable annotations. The Message should include: id (String), content (String), role (MessageRole enum: user/assistant/system), timestamp (DateTime), status (MessageStatus enum: sending/sent/streaming/complete/error). Implement proper equality, validation rules, and business invariants. Create lib/core/constants/app_constants.dart for API endpoints and configuration following the core package structure.",
        "testStrategy": "Comprehensive unit tests for Message Value Object including: serialization/deserialization with json_serializable, enum value handling and edge cases, model equality comparisons and hashCode consistency, validation rules for required fields and business constraints, immutability verification with freezed, and proper error handling for invalid inputs. Test coverage should exceed 90% following DDD testing principles.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create MessageRole and MessageStatus Enums",
            "description": "Implement MessageRole enum (user, assistant, system) and MessageStatus enum (sending, sent, streaming, complete, error) as Value Objects in lib/features/chat/domain/value_objects/ with proper validation and json_serializable annotations",
            "dependencies": [],
            "details": "Create MessageRole enum with values: user, assistant, system. Create MessageStatus enum with values: sending, sent, streaming, complete, error. Both enums should be implemented as Value Objects with freezed annotations, json_serializable support, and proper validation methods. Include toString() methods and extension methods for business logic.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Design Message Value Object Structure",
            "description": "Create the core Message Value Object class structure in lib/features/chat/domain/entities/message.dart with all required fields and freezed annotations",
            "dependencies": [
              "2.1"
            ],
            "details": "Define Message class as immutable Value Object with fields: id (String), content (String), role (MessageRole), timestamp (DateTime), status (MessageStatus). Use @freezed annotation with json_serializable support. Include factory constructors and copyWith methods.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Message Validation Rules",
            "description": "Add comprehensive validation logic to Message Value Object including business rules and invariants",
            "dependencies": [
              "2.2"
            ],
            "details": "Implement validation for: non-empty content, valid role values, timestamp constraints, status transitions. Create custom validation methods and ensure proper error handling. Add business invariants like message content length limits and valid role-status combinations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add JSON Serialization Support",
            "description": "Implement complete JSON serialization and deserialization for Message and enums using json_serializable",
            "dependencies": [
              "2.3"
            ],
            "details": "Add @JsonSerializable() annotations, implement fromJson() and toJson() methods. Handle DateTime serialization, enum conversion, and null safety. Ensure proper field mapping and custom converters if needed.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create App Constants File",
            "description": "Implement lib/core/constants/app_constants.dart with API endpoints and configuration following core package structure",
            "dependencies": [],
            "details": "Create AppConstants class with static constants for: OpenAI API endpoints, configuration values, default message limits, timeout values, and other chat-related constants. Follow the core package structure and naming conventions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Equality and HashCode",
            "description": "Ensure proper equality comparison and hashCode implementation for all Value Objects",
            "dependencies": [
              "2.4"
            ],
            "details": "Verify freezed generates proper equality and hashCode methods. Test deep equality for complex objects, ensure consistent hashCode behavior, and validate immutability constraints. Add custom equality logic if needed for business rules.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Write Comprehensive Unit Tests",
            "description": "Create complete test coverage for all data models including serialization, validation, and business rules",
            "dependencies": [
              "2.6"
            ],
            "details": "Create test files for Message, MessageRole, and MessageStatus. Test: JSON serialization/deserialization, validation rules and edge cases, equality and hashCode consistency, enum value handling, immutability verification, and business constraint enforcement.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Generate Code and Verify Integration",
            "description": "Run code generation for freezed and json_serializable, then verify all models work correctly together",
            "dependencies": [
              "2.7"
            ],
            "details": "Execute 'flutter packages pub run build_runner build' to generate required code. Verify compilation success, test model instantiation, validate serialization works end-to-end, and ensure all business rules function correctly. Fix any generation issues.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Chat Bloc State Management",
        "description": "Create BLoC pattern implementation for chat state management with proper events and states",
        "details": "Create lib/features/chat/bloc/chat_bloc.dart with ChatBloc extending Bloc<ChatEvent, ChatState>. Define events: SendMessage, StopGeneration, ClearChat. Define states: ChatInitial, ChatLoading, ChatReady(List<Message> messages, bool isStreaming), ChatError(String error). Implement event handlers with proper state transitions and error handling using try-catch blocks.",
        "testStrategy": "Unit tests for each event handler, state transitions, error scenarios, and bloc state persistence during streaming",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ChatEvent Abstract Class and Concrete Events",
            "description": "Define the abstract ChatEvent class and implement concrete event classes: SendMessage, StopGeneration, and ClearChat with proper parameters and validation",
            "dependencies": [],
            "details": "Create abstract ChatEvent class in lib/features/chat/bloc/chat_event.dart. Implement SendMessage event with required message parameter and validation. Create StopGeneration event for canceling ongoing operations. Implement ClearChat event for resetting chat history. Add proper documentation and type safety.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create ChatState Abstract Class and Concrete States",
            "description": "Define the abstract ChatState class and implement all concrete state classes with proper data structures and equality",
            "dependencies": [],
            "details": "Create abstract ChatState class in lib/features/chat/bloc/chat_state.dart. Implement ChatInitial for initial state, ChatLoading for processing states, ChatReady with messages list and isStreaming flag, and ChatError with error message. Add Equatable implementation for proper state comparison and rebuild optimization.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement ChatBloc Class Structure",
            "description": "Create the main ChatBloc class extending Bloc with proper initialization, dependency injection, and event registration",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Create ChatBloc class in lib/features/chat/bloc/chat_bloc.dart extending Bloc<ChatEvent, ChatState>. Set up constructor with required dependencies, initialize with ChatInitial state, and register event handlers. Add proper disposal methods and stream subscription management for cleanup.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement SendMessage Event Handler",
            "description": "Create comprehensive SendMessage event handler with streaming support, error handling, and proper state transitions",
            "dependencies": [
              "3.3"
            ],
            "details": "Implement _onSendMessage handler with try-catch error handling. Add message to state, emit ChatLoading, integrate with AI service for streaming responses, handle token-by-token updates, and emit ChatReady with updated messages. Include proper error handling and state rollback on failures.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement StopGeneration and ClearChat Event Handlers",
            "description": "Create event handlers for stopping message generation and clearing chat history with proper cleanup",
            "dependencies": [
              "3.3"
            ],
            "details": "Implement _onStopGeneration handler to cancel active stream subscriptions and update isStreaming flag. Create _onClearChat handler to reset messages list and return to ChatInitial state. Ensure proper cleanup of resources and state consistency during transitions.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add Comprehensive Unit Tests for ChatBloc",
            "description": "Create complete test suite covering all event handlers, state transitions, error scenarios, and edge cases",
            "dependencies": [
              "3.4",
              "3.5"
            ],
            "details": "Create test/features/chat/bloc/chat_bloc_test.dart with bloc_test framework. Test initial state, all event handlers, error scenarios, state transitions, stream cancellation, and concurrent event handling. Include edge cases like rapid message sending and network failures. Ensure 100% code coverage for the bloc implementation.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Build OpenAI Provider Integration",
        "description": "Implement OpenAI API client with streaming support for real-time chat responses",
        "details": "Create lib/infrastructure/providers/openai/openai_client.dart using Dio for HTTP requests. Implement streamChat method that sends POST to https://api.openai.com/v1/chat/completions with stream:true. Handle Server-Sent Events using dio.responseStream. Create lib/infrastructure/providers/openai/streaming_handler.dart to parse SSE data chunks and emit partial responses. Include proper error handling for network issues, API limits, and malformed responses.",
        "testStrategy": "Integration tests with mock OpenAI responses, unit tests for SSE parsing, error handling for various API error codes, and timeout scenarios",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create OpenAI client class with Dio configuration",
            "description": "Set up the basic OpenAI client class with Dio HTTP client configuration, including base URL, headers, and authentication setup",
            "dependencies": [],
            "details": "Create lib/infrastructure/providers/openai/openai_client.dart with OpenAIClient class. Configure Dio instance with base URL (https://api.openai.com/v1), proper headers including Authorization bearer token, content-type application/json, and timeout settings. Add constructor to accept API key parameter.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement basic chat completion API call structure",
            "description": "Create the foundation for chat completion requests with proper request formatting and basic response handling",
            "dependencies": [
              "4.1"
            ],
            "details": "Implement chatCompletion method in OpenAIClient that constructs proper request body with model, messages array, and other parameters. Create request/response model classes for OpenAI API format. Handle basic HTTP POST to /chat/completions endpoint without streaming.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add streaming support with Server-Sent Events handling",
            "description": "Extend the client to support streaming responses using Dio's response stream capabilities",
            "dependencies": [
              "4.2"
            ],
            "details": "Implement streamChat method that sends POST request with stream:true parameter. Use dio.responseStream to handle streaming response. Set up proper stream subscription and manage connection lifecycle including cleanup on cancellation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create streaming response parser for SSE data chunks",
            "description": "Build dedicated handler to parse Server-Sent Events data and extract message chunks",
            "dependencies": [
              "4.3"
            ],
            "details": "Create lib/infrastructure/providers/openai/streaming_handler.dart with StreamingHandler class. Parse SSE format (data: prefix, JSON content, [DONE] termination). Extract delta content from OpenAI response format and emit partial message updates as Stream<String>.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement comprehensive error handling for various API scenarios",
            "description": "Add robust error handling for network issues, API rate limits, authentication failures, and malformed responses",
            "dependencies": [
              "4.4"
            ],
            "details": "Create custom exception classes for different error types (NetworkException, ApiLimitException, AuthenticationException, ParseException). Implement try-catch blocks with specific error detection based on HTTP status codes (401, 429, 500, etc.) and response content. Add retry logic for transient failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add proper request/response models for OpenAI API",
            "description": "Create comprehensive data models for OpenAI API request and response structures with proper serialization",
            "dependencies": [
              "4.2"
            ],
            "details": "Create models for ChatCompletionRequest (model, messages, stream, temperature, etc.), ChatCompletionResponse, Message, Choice, and Delta objects. Add json_annotation and generate serialization code. Ensure models handle both streaming and non-streaming response formats.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create integration tests with mock responses and error scenarios",
            "description": "Develop comprehensive test suite covering successful requests, streaming responses, and various error conditions",
            "dependencies": [
              "4.5",
              "4.6"
            ],
            "details": "Create test files for OpenAIClient and StreamingHandler. Mock Dio responses for successful chat completion, streaming data chunks, authentication errors, rate limiting, and network failures. Test stream cancellation, proper resource cleanup, and error propagation throughout the integration.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Create Message Input Widget",
        "description": "Build the text input component with send button and proper keyboard handling following Material Design 3 guidelines with multiline support and enhanced UX features",
        "status": "pending",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "Create lib/features/chat/ui/message_input.dart as StatefulWidget with TextEditingController for multiline input support. Implement TextField with Material Design 3 styling following the design system specifications (design-system.json:inputs). Include dynamic height adjustment for multiline text, send IconButton with loading states, Enter key submission (with Shift+Enter for new lines), comprehensive input validation (non-empty, max length), proper focus management, and error feedback UI. Apply design system colors, spacing, and border radius values. Support keyboard shortcuts and accessibility features. Handle loading states during message sending with visual feedback.",
        "testStrategy": "Widget tests for multiline input behavior, send button states, keyboard shortcuts (Enter vs Shift+Enter), validation feedback, focus management, loading states, accessibility features, and proper Material Design 3 theming integration",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic MessageInput Widget Structure",
            "description": "Create the foundational StatefulWidget structure with TextEditingController and basic Material Design 3 styling",
            "dependencies": [],
            "details": "Create lib/features/chat/ui/message_input.dart as StatefulWidget with proper lifecycle management. Initialize TextEditingController and FocusNode. Set up basic widget structure with Container/Card wrapper following Material Design 3 principles. Implement dispose method for proper resource cleanup.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Multiline TextField with Dynamic Height",
            "description": "Build the core TextField with multiline support and dynamic height adjustment based on content",
            "dependencies": [
              "5.1"
            ],
            "details": "Implement TextField with maxLines: null for unlimited lines, minLines: 1 for single line start. Add dynamic height constraints with maxHeight limit. Configure textCapitalization, textInputAction, and keyboardType properties. Apply Material Design 3 input styling from design-system.json including proper padding, border radius, and colors.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add Send Button with Loading States",
            "description": "Create send IconButton with proper loading states and Material Design 3 styling",
            "dependencies": [
              "5.1"
            ],
            "details": "Implement send IconButton with Icons.send using Material Design 3 styling. Add loading state with CircularProgressIndicator replacement when message is being sent. Handle button enabled/disabled states based on input validation. Apply proper colors and sizing from design system tokens.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Keyboard Shortcuts and Input Handling",
            "description": "Add keyboard shortcuts for Enter key submission and Shift+Enter for new lines",
            "dependencies": [
              "5.2"
            ],
            "details": "Implement onSubmitted callback for Enter key to send message. Add RawKeyboardListener or KeyboardListener to handle Shift+Enter for new line insertion without sending. Configure proper keyboard shortcuts and prevent default behaviors when appropriate. Handle mobile vs desktop keyboard differences.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add Input Validation and Error Feedback",
            "description": "Implement comprehensive input validation with visual error feedback",
            "dependencies": [
              "5.2"
            ],
            "details": "Add validation for non-empty input (trim whitespace), maximum character length limits, and any business rules. Implement error text display below TextField with proper Material Design 3 error styling. Add visual feedback for validation states using design system error colors. Handle real-time validation on text changes.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Focus Management and UX Features",
            "description": "Add proper focus management and enhanced UX features for better user experience",
            "dependencies": [
              "5.3",
              "5.4"
            ],
            "details": "Implement automatic focus management when widget appears. Add focus retention during message sending. Implement proper cursor positioning and text selection handling. Add haptic feedback for button interactions. Handle focus changes between send button and text field appropriately.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Add Accessibility Features and ARIA Support",
            "description": "Implement comprehensive accessibility features following Flutter accessibility guidelines",
            "dependencies": [
              "5.5"
            ],
            "details": "Add proper semantics labels and hints for screen readers. Implement semantic announcements for state changes (loading, errors, sent messages). Add proper accessibility traversal order. Configure appropriate semantic roles and actions. Test with screen readers and accessibility tools to ensure WCAG compliance.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Integrate Design System Tokens and Final Polish",
            "description": "Apply complete design system integration and final UX polish with comprehensive testing",
            "dependencies": [
              "5.6",
              "5.7"
            ],
            "details": "Integrate all design system tokens from design-system.json for colors, spacing, typography, and border radius. Add smooth animations for loading states and height changes. Implement proper theming support for light/dark modes. Add comprehensive widget tests covering all functionality. Perform final UX review and polish including edge case handling.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Message Bubble Component",
        "description": "Create message display widget with proper styling for user and AI messages following Material Design 3 shape system and project design tokens",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "details": "Create apps/tina_app/lib/features/chat/ui/message_bubble.dart implementing a StatelessWidget that displays chat messages with role-based styling. User messages: right-aligned with primary.base (#2563EB) background, white text, and trailing alignment. AI messages: left-aligned with neutral.100 (#F1F5F9) background, neutral.800 (#1E293B) text, and leading alignment. Implement Material Design 3 shape system using borders.radius.lg (0.5rem) for message bubbles. Integrate flutter_markdown (to be added to pubspec.yaml) for AI response rendering. Add message status indicators using semantic colors (success: #22C55E for sent, warning: #F59E0B for sending, error: #EF4444 for failed). Include timestamp display using typography.scale.xs (0.75rem) with neutral.500 color. Apply responsive width constraints with maximum 85% screen width and proper spacing.layout.componentSpacing (1rem) margins. Follow design-system.json color palette and typography scale for consistent theming.",
        "testStrategy": "Widget tests for different message types (user/AI), markdown rendering verification, status indicator states (sending/sent/error), timestamp formatting, responsive layout behavior at different screen widths, and proper Material Design 3 theming integration using project design tokens",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic Message Bubble Widget Structure",
            "description": "Create the foundational StatelessWidget for message bubble at apps/tina_app/lib/features/chat/ui/message_bubble.dart with basic constructor and required parameters for message data and role",
            "dependencies": [],
            "details": "Implement MessageBubble StatelessWidget with required parameters: message content, sender role (user/AI), timestamp, and optional status. Define the basic widget structure with proper imports and class declaration following Flutter conventions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Role-Based Styling System",
            "description": "Add conditional styling logic for user vs AI messages with proper alignment, colors, and positioning based on message role",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement styling differentiation where user messages are right-aligned with primary.base (#2563EB) background and white text, while AI messages are left-aligned with neutral.100 (#F1F5F9) background and neutral.800 (#1E293B) text. Use CrossAxisAlignment and MainAxisAlignment for proper positioning.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate Material Design 3 Shape System",
            "description": "Apply Material Design 3 border radius and shape styling using design system tokens for consistent bubble appearance",
            "dependencies": [
              "6.2"
            ],
            "details": "Implement borders.radius.lg (0.5rem) from design-system.json for message bubble containers. Apply consistent shape styling using Container decoration with BorderRadius.circular and proper Material Design 3 principles.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add flutter_markdown Dependency and Integration",
            "description": "Add flutter_markdown to pubspec.yaml and integrate markdown rendering capability for AI message content display",
            "dependencies": [
              "6.3"
            ],
            "details": "Update pubspec.yaml to include flutter_markdown dependency. Implement conditional rendering where AI messages use MarkdownBody widget while user messages use regular Text widget. Configure markdown styling to match design system typography.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create Message Status Indicator System",
            "description": "Implement status indicators using semantic colors for message states (sending, sent, error) with appropriate icons",
            "dependencies": [
              "6.4"
            ],
            "details": "Create status indicator widgets using semantic colors: success (#22C55E) for sent, warning (#F59E0B) for sending, error (#EF4444) for failed. Implement small icon indicators positioned appropriately for each message role with proper color coding.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add Timestamp Display Component",
            "description": "Implement timestamp display using typography scale and proper positioning relative to message bubbles",
            "dependencies": [
              "6.5"
            ],
            "details": "Add timestamp display using typography.scale.xs (0.75rem) with neutral.500 color from design-system.json. Position timestamps appropriately for user (bottom-right) and AI (bottom-left) messages with proper spacing and formatting.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Responsive Design Constraints",
            "description": "Add responsive width constraints and proper spacing following the layout system specifications",
            "dependencies": [
              "6.6"
            ],
            "details": "Implement maximum 85% screen width constraint using MediaQuery and Flexible widgets. Apply spacing.layout.componentSpacing (1rem) margins and ensure proper responsive behavior across different screen sizes with appropriate padding and margins.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Apply Design System Token Integration",
            "description": "Ensure all styling follows design-system.json tokens for colors, typography, and spacing with consistent theming",
            "dependencies": [
              "6.7"
            ],
            "details": "Review and enforce consistent usage of design-system.json tokens throughout the component. Verify color palette, typography scale, spacing values, and ensure proper integration with the project's theming system for maintainable and consistent styling.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Build Main Chat Screen",
        "description": "Create the primary chat interface combining all components with proper layout and scrolling",
        "details": "Create lib/features/chat/ui/chat_screen.dart as StatelessWidget using BlocBuilder for state management. Include AppBar with title and stop generation button, ListView.builder for messages with reverse scrolling, MessageInput at bottom using SafeArea. Implement auto-scroll to bottom on new messages, scroll position maintenance during streaming, and proper keyboard handling with bottomInset behavior.",
        "testStrategy": "Widget tests for layout components, integration tests for message flow, scroll behavior testing, and keyboard interaction testing",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Basic ChatScreen StatelessWidget Structure",
            "description": "Set up the foundational ChatScreen widget with BlocBuilder integration and basic scaffold structure",
            "dependencies": [],
            "details": "Create lib/features/chat/ui/chat_screen.dart as StatelessWidget. Implement BlocBuilder<ChatBloc, ChatState> wrapper with proper state handling. Set up Scaffold with basic structure and import necessary dependencies including chat bloc and related models.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement AppBar with Stop Generation Functionality",
            "description": "Add AppBar component with title and stop generation button functionality",
            "dependencies": [
              "7.1"
            ],
            "details": "Create AppBar with 'Chat' title and stop generation IconButton. Implement stop generation functionality by dispatching StopGeneration event to ChatBloc. Show stop button only when isStreaming is true in ChatReady state. Style according to Material Design 3 principles.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add ListView.builder for Messages with Reverse Scrolling",
            "description": "Implement scrollable message list with proper reverse scrolling configuration",
            "dependencies": [
              "7.1"
            ],
            "details": "Create ListView.builder in Scaffold body with reverse: true for bottom-to-top message display. Set up ScrollController for programmatic scrolling control. Implement message rendering using MessageBubble widgets with proper itemCount based on ChatState messages list.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate MessageInput Widget with Proper Positioning",
            "description": "Add MessageInput component to screen bottom with SafeArea and keyboard handling",
            "dependencies": [
              "7.3"
            ],
            "details": "Position MessageInput widget at bottom of screen using Column layout. Wrap with SafeArea for proper inset handling. Set Scaffold resizeToAvoidBottomInset to true for keyboard behavior. Ensure MessageInput maintains position above keyboard when opened.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Auto-scroll Behavior for New Messages",
            "description": "Add automatic scrolling to bottom when new messages are received",
            "dependencies": [
              "7.3"
            ],
            "details": "Implement WidgetsBinding.instance.addPostFrameCallback to scroll to bottom after new messages. Use ScrollController.animateTo with appropriate duration and curve. Handle scroll behavior during streaming messages to maintain user position or auto-follow based on current scroll position.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Handle Keyboard Interactions and SafeArea Management",
            "description": "Implement comprehensive keyboard handling and SafeArea edge case management",
            "dependencies": [
              "7.4",
              "7.5"
            ],
            "details": "Fine-tune keyboard appearance animations and input field focus behavior. Implement proper SafeArea padding for different device orientations and screen sizes. Handle edge cases like keyboard dismissal, input field scrolling, and maintaining chat scroll position during keyboard operations.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Integrate Chat Components with BLoC",
        "description": "Connect all UI components with the chat BLoC for complete functionality",
        "details": "Wire ChatScreen with BlocProvider and BlocBuilder, connect MessageInput send action to SendMessage event, display messages from ChatReady state, show loading indicators during streaming, implement stop generation functionality, and handle error states with proper user feedback. Add BlocListener for side effects like scrolling and showing snackbars for errors.",
        "testStrategy": "Integration tests for complete user flow: send message → streaming response → display, error handling scenarios, and stop generation functionality",
        "priority": "high",
        "dependencies": [
          4,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up BlocProvider in widget tree",
            "description": "Configure BlocProvider to make ChatBloc accessible throughout the chat screen widget hierarchy",
            "dependencies": [],
            "details": "Wrap ChatScreen with BlocProvider<ChatBloc> in the widget tree, ensure proper bloc instance creation and disposal, and verify bloc is accessible to all child widgets that need it.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Connect MessageInput send actions to BLoC events",
            "description": "Wire MessageInput component to trigger SendMessage events when user submits messages",
            "dependencies": [
              "8.1"
            ],
            "details": "Implement onSend callback in MessageInput that dispatches SendMessage event to ChatBloc, pass message content and metadata, and ensure proper event triggering on submit actions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement BlocBuilder for displaying chat states and messages",
            "description": "Create BlocBuilder widgets to render different chat states and message lists based on ChatBloc state",
            "dependencies": [
              "8.1"
            ],
            "details": "Build UI for ChatInitial, ChatReady, ChatStreaming, and ChatError states. Display message list from ChatReady state, show streaming indicators during ChatStreaming, and render appropriate UI for each state transition.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add BlocListener for side effects",
            "description": "Implement BlocListener to handle side effects like auto-scrolling and error snackbars",
            "dependencies": [
              "8.3"
            ],
            "details": "Use BlocListener to scroll to bottom on new messages, show snackbars for error states, handle navigation side effects, and manage other UI side effects that don't directly update the widget tree.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement loading indicators during streaming",
            "description": "Add visual feedback during message streaming and generation states",
            "dependencies": [
              "8.3"
            ],
            "details": "Display loading indicators during ChatStreaming state, show typing indicators while AI is generating responses, implement shimmer effects for message placeholders, and provide clear visual feedback for ongoing operations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add stop generation functionality",
            "description": "Implement ability for users to stop ongoing message generation",
            "dependencies": [
              "8.3",
              "8.5"
            ],
            "details": "Add stop generation button in AppBar or message input area, connect button to StopGeneration event in ChatBloc, handle stream cancellation gracefully, and provide user feedback when generation is stopped.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create comprehensive error handling with user feedback",
            "description": "Implement robust error handling with clear user messaging and recovery options",
            "dependencies": [
              "8.4"
            ],
            "details": "Handle ChatError states with user-friendly messages, implement retry functionality for failed requests, show connection status and network errors clearly, and provide actionable error messages with recovery suggestions.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Error Handling and Loading States",
        "description": "Add comprehensive error handling, retry logic, and user feedback mechanisms following the project's architecture and design system",
        "status": "pending",
        "dependencies": [
          8
        ],
        "priority": "medium",
        "details": "Create a robust error handling system using the existing project architecture. Implement lib/core/utils/error_handler.dart following the package dependency rules (core packages only use pure Dart). Create error types aligned with the semantic color system (error: #EF4444) from design-system.json. Implement retry mechanisms for HTTP requests using the existing http: ^1.5.0 package. Add loading shimmer effects following Material Design 3 principles with the project's animation system (duration.normal: 200ms, easing.default). Create user-friendly error messages for network failures, API key issues, and rate limits. Add connection status indicators using the design system's semantic colors and proper error logging foundation for future crashlytics integration. All implementations should follow the monorepo package structure and use Provider pattern for state management as configured in pubspec.yaml.",
        "testStrategy": "Unit tests for error handler utilities in packages/tina_core/, widget tests for loading states and error UI components using flutter_test framework, integration tests for retry functionality with mock HTTP responses, error message display testing with different screen sizes using the responsive breakpoints from design-system.json, and comprehensive coverage of all error scenarios including network timeouts, API failures, and recovery flows",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Core Error Handler Package Structure",
            "description": "Set up error handling foundation following monorepo architecture",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Domain Error Types",
            "description": "Define error types for network, API, and application failures using semantic colors",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create HTTP Client with Retry Logic",
            "description": "Extend existing http package with exponential backoff retry mechanism",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build Error UI Components",
            "description": "Create error display widgets following Material Design 3 and design system tokens",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Loading State Components",
            "description": "Create shimmer effects and loading indicators using design system animations",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add Connection Status Indicators",
            "description": "Build network status widgets with semantic color feedback",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Integrate Error Logging Foundation",
            "description": "Set up error logging structure for future crashlytics integration",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create Provider State Management",
            "description": "Implement error and loading state providers using existing provider pattern",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Write Comprehensive Test Coverage",
            "description": "Create unit, widget, and integration tests for all error handling scenarios",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Add Streaming Response Features",
        "description": "Implement real-time streaming with stop generation and smooth UI updates",
        "details": "Enhance streaming implementation with token-by-token display using StreamBuilder, typing indicators while AI is generating, stop generation button that cancels the stream, smooth text animation during streaming, and proper cleanup of stream subscriptions. Optimize performance with debounced UI updates and efficient list rebuilding using keys.",
        "testStrategy": "Performance tests for streaming UI updates, functionality tests for stop generation, memory leak testing for stream cleanup, and stress testing with rapid message sending",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance UI with StreamBuilder for Real-time Updates",
            "description": "Implement StreamBuilder widget to display streaming responses in real-time with proper state management",
            "dependencies": [],
            "details": "Create StreamBuilder implementation in chat UI to listen to streaming responses. Replace static message display with dynamic streaming updates. Handle different stream states (waiting, active, completed, error) with appropriate UI feedback. Integrate with existing chat bloc to receive streaming data and update UI smoothly.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Token-by-token Text Display with Smooth Animations",
            "description": "Create smooth text animation system that displays AI responses character by character as they arrive",
            "dependencies": [
              "10.1"
            ],
            "details": "Implement AnimatedTextKit or custom animation controller for smooth text appearance. Create typewriter effect that shows tokens as they arrive from the stream. Add configurable animation speed and smooth transitions. Ensure animations are performant and don't block UI updates during rapid token arrival.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add Typing Indicators During AI Response Generation",
            "description": "Implement visual indicators to show when AI is actively generating a response",
            "dependencies": [
              "10.1"
            ],
            "details": "Create typing indicator widget with animated dots or pulse effect. Display indicator during streaming states and hide when complete or stopped. Position indicator appropriately in chat UI. Add loading shimmer effect for message container during generation. Ensure indicator responds correctly to stream state changes.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Stop Generation Button with Stream Cancellation",
            "description": "Implement stop button that allows users to cancel ongoing AI response generation",
            "dependencies": [
              "10.1"
            ],
            "details": "Add stop generation button that appears during streaming. Implement stream cancellation logic in chat bloc to properly terminate ongoing requests. Handle partial response preservation when stopped. Provide visual feedback for stop action and ensure clean state transition. Test cancellation at different stages of response generation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Optimize Performance with Debounced UI Updates",
            "description": "Implement debouncing and performance optimizations for smooth streaming UI updates",
            "dependencies": [
              "10.1",
              "10.2"
            ],
            "details": "Add debouncing mechanism to prevent excessive UI rebuilds during rapid token arrival. Implement efficient text buffer management for streaming updates. Use Timer or RxDart debouncing to batch UI updates. Optimize ListView rebuilding with proper keys and minimal widget reconstruction. Monitor and optimize memory usage during streaming.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Proper Stream Subscription Cleanup",
            "description": "Ensure proper disposal of stream subscriptions to prevent memory leaks",
            "dependencies": [
              "10.1",
              "10.4"
            ],
            "details": "Implement comprehensive cleanup logic in chat bloc dispose method. Cancel all active stream subscriptions on widget disposal or navigation. Add subscription management with proper error handling and resource cleanup. Create stream subscription pool for managing multiple concurrent streams. Test for memory leaks and ensure proper resource disposal.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Add Performance Testing and Memory Leak Prevention",
            "description": "Implement performance monitoring and testing for streaming features with memory leak detection",
            "dependencies": [
              "10.5",
              "10.6"
            ],
            "details": "Create performance tests for streaming UI updates and measure frame rates during streaming. Implement memory leak detection tests for stream subscriptions. Add performance monitoring for token processing speed and UI responsiveness. Create stress tests with rapid message sending and long streaming sessions. Document performance benchmarks and optimization recommendations.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-11T11:54:08.739Z",
      "updated": "2025-09-11T21:19:47.170Z",
      "description": "Tasks for master context"
    }
  }
}